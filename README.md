# PSP22 Fungible Token

PSP22 is a fungible token standard for WebAssembly smart contracts running on blockchains based on the [Substrate][substrate] framework. It is an equivalent of Ethereum's [ERC-20][erc20]. The definition of the PSP22 standard can be found [here][psp22].

This repository contains a simple, minimal implementation of the PSP22 token in [ink!][ink] programming language.

## How to use this repository

To use this crate please add the following line in your `Cargo.toml`:
```
psp22 = { git = "https://github.com/Cardinal-Cryptography/PSP22.git", default-features = false }
```

The contents of this repository can be used in following ways:

### 1. Ready to use contract

The file [`lib.rs`][lib] contains a ready to use implementation of basic PSP22 token contract (extended with PSP22Metadata). To use it, please check out this repository and compile its contents with [`cargo-contract`][cargo-contract] with the `"contract"` feature enabled:
```
$ cargo contract build --release --features "contract"
```
### 2. Cross contract calling with traits

The `PSP22` trait contains all the methods defined in the PSP22 standard. The trait can be used together with ink!'s [`contract_ref`][contract_ref] macro to allow for convenient cross-contract calling.

In your contract, if you would like to make a call to some other contract implementing the PSP22 standard, all you need to do is:
```
use ink::contract_ref;
use psp22::PSP22;

let mut token: contract_ref!(PSP22) = other_address.into();

// Now `token` has all the PSP22 methods
let balance = token.balance_of(some_account);
token.transfer(recipient, value); // returns Result<(), PSP22Error>
```

The same method can be used with other traits (`PSP22Metadata`, `PSP22Burnable`, `PSP22Mintable`) defined in this crate. See the contents of [`traits.rs`][traits].


### 3. Custom implementation of PSP22 logic with `PSP22Data`

The `PSP22Data` class can be used to extend your contract with PSP22 token logic. In other words, you can easily build contracts that implement PSP22 interface alongside some other functionalities defined by the business logic of your project.

The methods of the `PSP22Data` class correspond directly to queries and operations defined by the PSP22 token standard. To make your contract become a PSP22 token, you need to:
 - Put a single `PSP22Data` instance in your contract's storage and initialize it with some starting supply of tokens.
 - Add definitions of `Transfer` and `Approval` events in the body of your contract.
 - Add the `impl PSP22 for [struct_name]` block with implementation of PSP22 trait messages using `PSP22Data` methods. Each method which mutates the state of the token database returns a `Result<Vec<PSP22Event>, PSP22Error>` with all events generated by that operation. Please make sure to handle errors correctly and emit the resulting events (see the `emit_events` function).
 - Optionally implement also the `PSP22Metadata` trait to make your token play nice with other ecosystem tools.

The contract in [`lib.rs`][lib] contains an example implementation following all the above steps. Feel free to copy-paste parts of it.

### 4. Burnable and Mintable extensions

The `PSP22Data` class contains also `burn` and `mint` methods, which can be used to implement `PSP22Burnable` and `PSP22Mintable` extensions and make your token burnable and/or mintable. An example implementation follows the same pattern as for the base trait:
```
impl PSP22Burnable for Token {
    #[ink(message)]
    fn burn(&mut self, value: u128) -> Result<(), PSP22Error> {
        // Check if the caller is allowed to burn!
        let events = self.data.burn(self.env().caller(), value)?;
        self.emit_events(events);
        Ok(())
    }
}
```
Please note that `PSP22Data` `burn` and `mint` methods do not enforce any form of access control. It's probably not a good idea to have a token which can be minted and burned by anyone anytime. When implementing Burnable and Mintable extensions, please make sure that their usage is restricted according to your project's business logic. For example:
```
#[ink(storage)]
pub struct Token {
    data: PSP22Data,
    name: Option<String>,
    symbol: Option<String>,
    decimals: u8,
    owner: AccountId, // creator of the token
}

impl Token {
    #[ink(constructor)]
    pub fn new(
        supply: u128,
        name: Option<String>,
        symbol: Option<String>,
        decimals: u8,
    ) -> Self {
        Self {
            data: PSP22Data::new(supply, Self::env().caller()),
            name,
            symbol,
            decimals,
            owner: Self::env().caller(),
        }
    }
// ...
}

impl PSP22Burnable for Token {
    #[ink(message)]
    fn burn(&mut self, value: u128) -> Result<(), PSP22Error> {
        if self.env().caller() != self.owner {
            return PSP22Error::Custom(String::from("Only owner can burn"));
        }
        let events = self.data.burn(self.env().caller(), value)?;
        self.emit_events(events);
        Ok(())
    }
}
```


[lib]: ./lib.rs
[traits]: ./traits.rs
[ink]: https://use.ink
[substrate]: https://substrate.io
[cargo-contract]: https://github.com/paritytech/cargo-contract
[erc20]: https://ethereum.org/en/developers/docs/standards/tokens/erc-20/
[psp22]: https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md
[contract_ref]: https://paritytech.github.io/ink/ink/macro.contract_ref.html